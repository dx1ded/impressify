type Presentation {
  id: ID!
  name: String!
  slides: [Slide!]!
  users: [User!]!
  history: History!
}

type PresentationInfo {
  totalSlides: Int!
  totalUsers: Int!
  totalTextElements: Int!
  totalImageElements: Int!
  totalShapeElements: Int!
}

type PresentationState {
  name: String
  slides: [SlideStateItem!]
  # It's necessary to have `users` always present (even though they might've been not updated) because
  # ... the subscription filter needs it to send a message only to users who are in the presentation being updated
  users: [User!]!
  isSaving: Boolean
  # Here it's just being repassed from the input in order to gain access in the subscription filter
  _userUpdatedStateId: ID!
}

input PresentationStateInput {
  id: ID!
  name: String
  slides: [SlideInput!]
  users: [UserInput!]
  isSaving: Boolean
  # This field is needed for the subscription filter in order to not update state of the one's who sent the request
  _userUpdatedStateId: ID!
}

type Query {
  # @preview means you get only the first slide
  findUserPresentations(preview: Boolean!, sortBy: String!): [Presentation!]
  getPresentation(id: String!): Presentation
  searchPresentations(name: String!): [Presentation!]
  getPresentationInfo(id: String!): PresentationInfo
}

type Mutation {
  createPresentation(name: String!, template: String!): Presentation
  renamePresentation(id: ID!, name: String!): Presentation
  deletePresentation(id: ID!): Boolean
  duplicatePresentation(id: ID!): Presentation
  # this mutation won't do anything in the database or something like this.
  # this will only prepare data and call `pubsub.publish` to synchronize local states of every connection
  synchronizePresentationState(changes: PresentationStateInput!): PresentationState
}

type Subscription {
  presentationUpdated: PresentationState!
}
